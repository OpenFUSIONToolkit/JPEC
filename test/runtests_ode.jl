using LinearAlgebra

# TODO: perhaps this isn't the best place for this function?
# Should I do include("../dcon/utils.jl") instead? or maybe save these functions in a separate file?
# associated TODO: come up with Gaussian reduction test that doesn't rely on external data

function load_u_matrix(filename)
    lines = readlines(filename)
    data = [parse.(Float64, split(l)) for l in lines[2:end]]
    i_vals = Int.(getindex.(data, 1))
    j_vals = Int.(getindex.(data, 2))
    ncols = (length(data[1]) - 2) ÷ 2
    imax = maximum(i_vals)
    jmax = maximum(j_vals)
    mat = zeros(ComplexF64, imax, jmax, ncols)
    for row in data
        i = Int(row[1])
        j = Int(row[2])
        for k in 1:ncols
            re = Float64(row[2*k+1])
            im = Float64(row[2*k+2])
            mat[i, j, k] = complex(re, im)
        end
    end
    return mat
end

@testset "ODE Tests" begin
    @testset "ode_fixup!" begin
        # Initialize to random u
        msol = 5
        ifix = 1
        odet = JPEC.DCON.OdeState(msol, msol, 10, 10, 10)
        odet.u = randn(ComplexF64, msol, msol, 2)
        odet.unorm = [norm(odet.u[:, i, 1]) for i in 1:msol]
        odet.ifix = ifix
        odet.fixfac = zeros(ComplexF64, odet.msol, odet.msol, ifix)
        intr = JPEC.DCON.DconInternal()
        intr.mpert = msol
        outp = JPEC.DCON.DconOutput(; write_crit_out=false, write_dcon_out=false, write_euler_h5=false, write_eqdata_h5=false)

        # Save copy of original u and run
        u_orig = copy(odet.u)
        JPEC.DCON.ode_fixup!(odet, intr, outp, false, false)

        # Very simple tests
        @test !all(odet.u .== u_orig)  # u should have changed
        @test all(abs.(diag(odet.fixfac[:, :, ifix])) .≈ 1)  # diagonal of fixfac = 1

        # TODO: come up with triangularization check
        # --- Triangularization check (primary solutions) ---
        # for isol in 1:intr.mpert
        #     ksol = isol
        #     kpert = findmax(abs.(odet.u[:, ksol, 1]))[2]
        #     for jsol in 1:odet.msol
        #         if jsol != ksol
        #             println("kpert, jsol = ", kpert, ", ", jsol)
        #             @test isapprox(abs(odet.u[kpert, jsol, 1]), 0.0; atol=1e-12)
        #         end
        #     end
        # end

        # --- Real Fortran data check ---
        msol = 31
        odet = JPEC.DCON.OdeState(msol, msol, 10, 10, 10)
        # We'll load in Fortran data for u pulled before and after a fixup
        # Note that this was generated by manually setting
        # unorm = [norm(odet.u[:,i,1]) for i in 1:msol] in the Fortran to avoid
        # also having to save unorm0
        odet.u = load_u_matrix(joinpath(@__DIR__, "test_data", "u_prefixup.dat"))
        odet.unorm = [norm(odet.u[:, i, 1]) for i in 1:msol]
        odet.ifix = ifix
        odet.fixfac = zeros(ComplexF64, odet.msol, odet.msol, ifix)
        intr = JPEC.DCON.DconInternal(; mpert=msol)

        JPEC.DCON.ode_fixup!(odet, intr, outp, false, false)

        u_fortran = load_u_matrix(joinpath(@__DIR__, "test_data", "u_postfixup.dat"))
        # test that the outputs are approximately equivalent (1e-3 seems ok to account for loading differences)
        @test all(abs.(odet.u .- u_fortran) .< 1e-3)

    end

    @testset "ode_unorm!" begin
        msol = 2
        odet = JPEC.DCON.OdeState(msol, msol, 10, 10, 10)
        intr = JPEC.DCON.DconInternal()
        intr.mpert = msol
        ctrl = JPEC.DCON.DconControl()
        ctrl.ucrit = 10.0
        outp = JPEC.DCON.DconOutput(; write_crit_out=false, write_dcon_out=false, write_euler_h5=false, write_eqdata_h5=false)

        # Case 1: Basic norm computation
        odet.u = zeros(ComplexF64, 2, 2, 2)
        odet.u[:, 1, 1] .= [3, 4]          # norm = 5
        odet.u[:, 2, 1] .= [0, 2]          # norm = 2

        JPEC.DCON.ode_unorm!(odet, intr, ctrl, outp, false)
        # After the first run with new=True (default), unorm0 should be set to unorm
        # and new should be false
        @test odet.unorm[1:intr.mpert] ≈ [5, 2]
        @test odet.unorm0 == odet.unorm
        @test odet.new == false

        # Case 2: Error on zero norm
        odet.u[:, 1, 1] .= 0
        odet.new = true
        @test_throws ErrorException JPEC.DCON.ode_unorm!(odet, intr, ctrl, outp, false)

        # Case 3: Normalization on second call
        odet.u[:, 1, 1] .= [3, 4]   # norm = 5
        odet.u[:, 2, 1] .= [0, 2]   # norm = 2
        odet.new = false
        JPEC.DCON.ode_unorm!(odet, intr, ctrl, outp, false)
        @test odet.unorm[1:intr.mpert] ≈ [1, 1]

        # Case 4: Trigger fixup via ucrit
        odet.unorm0 = ones(2 * intr.mpert)
        odet.u[:, 1, 1] .= [1000, 0]   # large norm
        odet.u[:, 2, 1] .= [1, 0]      # small norm
        JPEC.DCON.ode_unorm!(odet, intr, ctrl, outp, false)
        @test odet.new == true  # implies fixup ran

        # Case 5: Trigger fixup via sing_flag
        odet.new = false
        odet.u[:, 1, 1] .= [1, 0]
        odet.u[:, 2, 1] .= [1, 0]
        JPEC.DCON.ode_unorm!(odet, intr, ctrl, outp, true)
        @test odet.new == true  # fixup triggered
    end
end