using LinearAlgebra

# TODO: perhaps this isn't the best place for this function?
# Should I do include("../dcon/utils.jl") instead? or maybe save these functions in a separate file?
function load_u_matrix(filename)
    lines = readlines(filename)
    data = [parse.(Float64, split(l)) for l in lines[2:end]]
    i_vals = Int.(getindex.(data, 1))
    j_vals = Int.(getindex.(data, 2))
    ncols = (length(data[1]) - 2) ÷ 2
    imax = maximum(i_vals)
    jmax = maximum(j_vals)
    mat = zeros(ComplexF64, imax, jmax, ncols)
    for row in data
        i = Int(row[1])
        j = Int(row[2])
        for k in 1:ncols
            re = Float64(row[2*k+1])
            im = Float64(row[2*k+2])
            mat[i, j, k] = complex(re, im)
        end
    end
    return mat
end

@testset "ODE Tests" begin
    @testset "ode_fixup!" begin
        # Initialize to random u
        msol = 5
        odet = JPEC.DconMod.OdeState(msol, msol)
        odet.u = randn(ComplexF64, msol, msol, 2)
        odet.unorm = [norm(odet.u[:,i,1]) for i in 1:msol]
        odet.fixfac = zeros(ComplexF64, odet.msol, odet.msol)
        intr = JPEC.DconMod.DconInternal()
        intr.mpert = msol

        # Save copy of original u and run
        u_orig = copy(odet.u)
        JPEC.DconMod.ode_fixup!(odet, intr, false, false)

        # Very simple tests
        @test !all(odet.u .== u_orig)  # u should have changed
        @test all(abs.(diag(odet.fixfac)) .≈ 1)  # diagonal of fixfac = 1

        # TODO: come up with triangularization check
        # --- Triangularization check (primary solutions) ---
        # for isol in 1:intr.mpert
        #     ksol = isol
        #     kpert = findmax(abs.(odet.u[:, ksol, 1]))[2]
        #     for jsol in 1:odet.msol
        #         if jsol != ksol
        #             println("kpert, jsol = ", kpert, ", ", jsol)
        #             @test isapprox(abs(odet.u[kpert, jsol, 1]), 0.0; atol=1e-12)
        #         end
        #     end
        # end

        # --- Real Fortran data check ---
        msol = 31
        odet = JPEC.DconMod.OdeState(msol, msol)
        # We'll load in Fortran data for u pulled before and after a fixup
        # Note that this was generated by manually setting 
        # unorm = [norm(odet.u[:,i,1]) for i in 1:msol] in the Fortran to avoid
        # also having to save unorm0
        odet.u = load_u_matrix(joinpath(@__DIR__, "test_data", "u_prefixup.dat"))
        odet.unorm = [norm(odet.u[:,i,1]) for i in 1:msol]
        odet.fixfac = zeros(ComplexF64, odet.msol, odet.msol)
        intr = JPEC.DconMod.DconInternal(mpert=msol)

        JPEC.DconMod.ode_fixup!(odet, intr, false, false)

        u_fortran = load_u_matrix(joinpath(@__DIR__, "test_data", "u_postfixup.dat"))
        # test that the outputs are approximately equivalent (1e-3 seems ok to account for loading differences)
        @test all(abs.(odet.u .- u_fortran) .< 1e-3)

    end
    # Add your tests here
end