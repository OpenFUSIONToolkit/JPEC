var documenterSearchIndex = {"docs":
[{"location":"equilibrium/#Equilibrium-Module","page":"Equilibrium","title":"Equilibrium Module","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"The Equilibrium module provides tools to read, construct, and analyze magnetohydrodynamic (MHD) plasma equilibria. It wraps a variety of equilibrium file formats (EFIT, CHEASE, SOL, LAR, and others), runs the appropriate direct or inverse solver, and returns a processed PlasmaEquilibrium object ready for downstream calculations.","category":"page"},{"location":"equilibrium/#Overview","page":"Equilibrium","title":"Overview","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Key responsibilities of the module:","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Read equilibrium input files and TOML configuration (see EquilibriumConfig).\nProvide convenient constructors for analytic / model equilibria (Large","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Aspect Ratio, Solev'ev).","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Build spline representations used throughout the code (1D cubic and","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"2D bicubic splines).","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Run the direct or inverse equilibrium solver and post-process results","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"(global parameters, q-profile finding, separatrix finding, GSE checks).","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"The module exposes a small public API that covers setup, configuration, and common analyses used by other JPEC components (e.g. DCON, vacuum interfaces).","category":"page"},{"location":"equilibrium/#API-Reference","page":"Equilibrium","title":"API Reference","text":"","category":"section"},{"location":"equilibrium/#JPEC.Equilibrium.DirectBField","page":"Equilibrium","title":"JPEC.Equilibrium.DirectBField","text":"DirectBField\n\nInternal mutable struct to hold B-field components and their derivatives at a point. It is used as a temporary workspace to avoid allocations in tight loops.\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.DirectRunInput","page":"Equilibrium","title":"JPEC.Equilibrium.DirectRunInput","text":"DirectRunInput(...)\n\nA container struct that bundles all necessary inputs for the direct_run function. It is created by the _read_efit function after parsing the raw equilibrium file and preparing the initial splines.\n\nFields:\n\nequil_input: The original EquilInput object.\nsq_in       # x value: psin       # Quantity 1: F = R*Bt  [m T]       # Quantity 2: mu0 * Pressure (non-negative) [nt^2 / m^2 * mu0 = T^2]       # Quantity 3: q-profile       # Quantity 4: sqrt(psi_norm)\npsi_in:       # x, y value: R, Z [m]       # z value : poloidal flux adjusted to be zero at the boundary [Weber/radian]           # 1. ψ(R,Z) = ψ_boundary - ψ(R,Z)           # 2. if ψ = ψ * sign(ψ(centerR,centerZ))\nrmin: Minimum R-coordinate of the computational grid [m].\nrmax: Maximum R-coordinate of the computational grid [m].\nzmin: Minimum Z-coordinate of the computational grid [m].\nzmax: Maximum Z-coordinate of the computational grid [m].\npsio: The total flux difference abs(ψ_axis - ψ_boundary) [Weber / radian].\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.EquilibriumConfig","page":"Equilibrium","title":"JPEC.Equilibrium.EquilibriumConfig","text":"EquilibriumConfig(...)\n\nA container struct that bundles all necessary configuration settings originally specified in the equil     fortran namelsits.\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.EquilibriumConfig-Tuple{Dict, Dict}","page":"Equilibrium","title":"JPEC.Equilibrium.EquilibriumConfig","text":"Constructor that allows users to form a EquilibriumConfig struct from dictionaries     for convinience when most of the defaults are fine.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.FieldLineDerivParams","page":"Equilibrium","title":"JPEC.Equilibrium.FieldLineDerivParams","text":"FieldLineDerivParams\n\nA struct to hold constant parameters for the ODE integration, making them easily accessible within the derivative function direct_fl_der!.\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.InverseRunInput","page":"Equilibrium","title":"JPEC.Equilibrium.InverseRunInput","text":"InverseRunInput(...)\n\nA container struct for inputs to the inverse_run function.\n\nFields:\n\nequil_input: The original EquilInput object.\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.LargeAspectRatioConfig","page":"Equilibrium","title":"JPEC.Equilibrium.LargeAspectRatioConfig","text":"LargeAspectRatioConfig(...)\n\nA mutable struct holding parameters for the Large Aspect Ratio (LAR) plasma equilibrium model.\n\nFields:\n\nlar_r0: The major radius of the plasma [m].\nlar_a: The minor radius of the plasma [m].\nbeta0: The beta value on axis (normalized pressure).\nq0: The safety factor on axis.\np_pres: The exponent for the pressure profile, defined as p00 * (1 - (r / a)^2)^p_pres.\np_sig: The exponent that determines the shape of the current-related function profile.\nsigma_type: The type of sigma profile, can be \"default\" or \"wesson\". If \"wesson\", the sigma profile is defined as sigma0 * (1 - (r / a)^2)^p_sig.\nmtau: The number of grid points in the poloidal direction.\nma: The number of grid points in the radial direction.\nzeroth: If set to true, it neglects the Shafranov shift\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.LargeAspectRatioConfig-Tuple{String}","page":"Equilibrium","title":"JPEC.Equilibrium.LargeAspectRatioConfig","text":"Outer constructor for LargeAspectRatioConfig that enables a toml file     interface for specifying the configuration settings\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.PlasmaEquilibrium","page":"Equilibrium","title":"JPEC.Equilibrium.PlasmaEquilibrium","text":"PlasmaEquilibrium(...)\n\nThe final, self-contained result of the equilibrium reconstruction. This object provides a complete representation of the processed plasma equilibrium in flux coordinates.\n\nFields:\n\nequil_input: The original EquilInput object used for the reconstruction.\nsq: The final 1D profile spline (CubicSpline{Float64}).       # x value: normalized psi       # Quantity 1: Toroidal Field Function * 2π, F * 2π (where F = R * B_toroidal)       # Quantity 2: Pressure * μ₀, P * μ₀.       # Quantity 3: dVdpsi       # Quantity 4: q\nrzphi: The final 2D flux-coordinate mapping spline (BicubicSpline).       # x value: normlized psi       # y value: SFL poloidal angle [0,1]       # Quantity 1: rcoord² = (R - ro)² + (Z - zo)²       # Quantity 2: Offset between the geometric poloidal angle (η) and the new angle (θnew)                    `η / (2π) - θ_new       # Quantity 3: ν in ϕ=2πζ+ν(ψ,θ)       # Quantity 4: Jacobian.\neqfun: A 2D spline storing local physics and geometric quantities that vary across the flux surfaces.       # These are pre-calculated for efficient use in subsequent stability and transport codes.       # x value: Normalized poloidal flux, ψnorm ∈ [0, 1].       # y value: SFL poloidal angle, θnew ∈ [0, 1].       # Quantity 1: Total magnetic field strength, B [T]       # Quantity 2: (e₁⋅e₂ + q⋅e₃⋅e₁) / (J⋅B²).       # Quantity 3: (e₂⋅e₃ + q⋅e₃⋅e₃) / (J⋅B²).\nro: R-coordinate of the magnetic axis [m].\nzo: Z-coordinate of the magnetic axis [m].\npsio: Total flux difference |Ψ_axis - Ψ_boundary| [Weber / radian].\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.SolevevConfig","page":"Equilibrium","title":"JPEC.Equilibrium.SolevevConfig","text":"SolevevConfig(...)\n\nA mutable struct holding parameters for the Solev'ev (SOL) plasma equilibrium model.\n\nFields:\n\nmr: number of radial grid zones\nmz: number of axial grid zones\nma: number of flux grid zones\ne:  elongation\na: minor radius\nr0: major radius\nq0: safety factor at the o-point\np0fac: scale on-axis pressure (P-> P+P0*p0fac. beta changes. Phi,q constant)\nb0fac: scale toroidal field at constant beta (sPhi,sf,s^2*P. bt changes. Shape,beta constant)\nf0fac: scale toroidal field at constant pressure (s*f. beta,q changes. Phi,p,bp constant)\n\n\n\n\n\n","category":"type"},{"location":"equilibrium/#JPEC.Equilibrium.SolevevConfig-Tuple{String}","page":"Equilibrium","title":"JPEC.Equilibrium.SolevevConfig","text":"Outer constructor for LarConfig that enables a toml file     interface for specifying the configuration settings\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium._read_1d_gfile_format-Tuple{Vector{String}, Int64}","page":"Equilibrium","title":"JPEC.Equilibrium._read_1d_gfile_format","text":"read1dgfileformat(linesblock, numvalues)\n\nInternal helper function to parse Fortran-style fixed-width numerical blocks from a vector of strings.\n\nArguments:\n\nlines_block: A Vector{String} containing the lines to parse.\nnum_values: The total number of Float64 values to read from the block.\n\nReturns:\n\nA Vector{Float64} containing the parsed values.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.direct_fl_der!-Tuple{Any, Any, JPEC.Equilibrium.FieldLineDerivParams, Any}","page":"Equilibrium","title":"JPEC.Equilibrium.direct_fl_der!","text":"direct_fl_der!(dy, y, params, eta)\n\nThe derivative function for the field-line integration ODE. This is passed to the DifferentialEquations.jl solver.\n\nArguments:\n\ndy: The derivative vector (output, modified in-place).\ny: The state vector [∫(dl/Bp), rfac, ∫(dl/(R²Bp)), ∫(jac*dl/Bp)].\nparams: A FieldLineDerivParams struct with all necessary parameters.\neta: The independent variable (geometric angle η).\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.direct_fl_int-Tuple{Int64, Float64, JPEC.Equilibrium.DirectRunInput, Float64, Float64, Float64}","page":"Equilibrium","title":"JPEC.Equilibrium.direct_fl_int","text":"direct_fl_int(ipsi, psifac, raw_profile, ro, zo, rs2)\n\nPerforms the field-line integration for a single flux surface.\n\nArguments:\n\nipsi: The index of the current flux surface.\npsifac: The normalized psi value for the surface (ψ_norm).\nraw_profile: The DirectRunInput object containing splines and parameters.\nro, zo: Coordinates of the magnetic axis [m].\nrs2: R-coordinate of the outboard separatrix [m].\n\nReturns:\n\ny_out: A matrix containing the integrated quantities vs. the geometric angle η.\nbf_start: A DirectBField object with values at the integration start point.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.direct_get_bfield!-Tuple{JPEC.Equilibrium.DirectBField, Float64, Float64, JPEC.SplinesMod.BicubicSpline, JPEC.SplinesMod.CubicSpline, Float64}","page":"Equilibrium","title":"JPEC.Equilibrium.direct_get_bfield!","text":"direct_get_bfield!(bf_out, r, z, psi_in, sq_in, psio; derivs=0)\n\nCalculates the magnetic field and its derivatives at a given (R,Z) point. The results are stored in-place in the bf_out object.\n\nArguments:\n\nbf_out: A mutable DirectBField struct to store the results.\nr: The R-coordinate [m].\nz: The Z-coordinate [m].\npsi_in: The 2D bicubic spline for poloidal flux ψ(R,Z).\nsq_in: The 1D cubic spline for profiles F(ψ_norm) and P(ψ_norm).\npsio: The total flux difference |ψ_axis - ψ_boundary|.\n\nKeyword Arguments:\n\nderivs: An integer specifying the derivative level to compute.\n0: Calculates ψ, F, and P.\n1: Also calculates 1st derivatives of ψ and B field components.\n2: Also calculates 2nd derivatives of ψ and 1st derivatives of B.\n\nReturns:\n\nnothing. The bf_out object is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.direct_position-Tuple{JPEC.SplinesMod.BicubicSpline, JPEC.SplinesMod.CubicSpline, Vararg{Float64, 5}}","page":"Equilibrium","title":"JPEC.Equilibrium.direct_position","text":"direct_position(psi_in, sq_in, psio, ro_guess, zo_guess, rmin, rmax)\n\nFinds the key geometric locations of the equilibrium: the magnetic axis (O-point) and the inboard/outboard separatrix crossings on the midplane.\n\nArguments:\n\npsi_in: The 2D ψ(R,Z) spline.\nsq_in: The 1D profile spline.\npsio: Initial flux difference.\nro_guess, zo_guess: Initial guess for the magnetic axis location [m].\nrmin, rmax: Radial bounds of the computational domain [m].\n\nReturns:\n\nro: R-coordinate of the magnetic axis [m].\nzo: Z-coordinate of the magnetic axis [m].\nrs1: R-coordinate of the inboard separatrix crossing [m].\nrs2: R-coordinate of the outboard separatrix crossing [m].\npsi_in_new : returns psi_in renormalized by * psio/psi(ro,zo)\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.direct_refine-Tuple{Float64, Float64, Float64, JPEC.Equilibrium.FieldLineDerivParams}","page":"Equilibrium","title":"JPEC.Equilibrium.direct_refine","text":"direct_refine(rfac, eta, psi0, params)\n\nRefines the radial distance rfac at a given angle eta to ensure the point lies exactly on the target flux surface psi0.\n\nArguments:\n\nrfac: The current guess for the radial distance from the magnetic axis.\neta: The geometric poloidal angle.\npsi0: The target ψ value for the flux surface.\nparams: A FieldLineDerivParams struct.\n\nReturns:\n\nThe refined rfac value.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.equilibrium_separatrix_find!-Tuple{JPEC.Equilibrium.PlasmaEquilibrium}","page":"Equilibrium","title":"JPEC.Equilibrium.equilibrium_separatrix_find!","text":"equilibrium_separatrix_find!(pe::PlasmaEquilibrium)\n\nFinds the separatrix locations in the plasma equilibrium (rsep, zsep, rext, zext).\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.equilibrium_solver-Tuple{JPEC.Equilibrium.DirectRunInput}","page":"Equilibrium","title":"JPEC.Equilibrium.equilibrium_solver","text":"equilibrium_solver(raw_profile)\n\nThe main driver for the direct equilibrium reconstruction. It orchestrates the entire process from finding the magnetic axis to integrating along field lines and constructing the final coordinate and physics quantity splines.\n\nArguments:\n\nraw_profile: A DirectRunInput object containing the initial splines (psi_in, sq_in) and run parameters (equil_input).\n\nReturns:\n\nA PlasmaEquilibrium object containing the final, processed equilibrium data, including the profile spline (sq), the coordinate mapping spline (rzphi), and the physics quantity spline (eqfun).\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.inverse_extrap-Tuple{Matrix{Float64}, Matrix{Float64}, Float64}","page":"Equilibrium","title":"JPEC.Equilibrium.inverse_extrap","text":"inverse_extrap(xx::Matrix{Float64}, ff::Matrix{Float64}, x::Float64) -> Vector{Float64}\n\nPerforms component-wise Lagrange extrapolation for a vector-valued function.\n\nArguments:\n\nxx: A (m × n) matrix where each row contains the x-values for each component.\nff: A (m × n) matrix where each row contains function values at the corresponding xx.\nx: A scalar Float64 value at which to extrapolate.\n\nReturns:\n\nA vector of length n representing the extrapolated function values at x.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.lar_init_conditions-Tuple{Float64, JPEC.Equilibrium.LargeAspectRatioConfig}","page":"Equilibrium","title":"JPEC.Equilibrium.lar_init_conditions","text":"lar_init_conditions(rmin, sigma_type, params)\n\nInitializes the starting radius and state vector for solving the LAR ODE system. Also evaluates the initial derivative using the analytic model.\n\nArguments:\n\nrmin: Normalized starting radius (as a fraction of lar_a).\nlar_input: A LargeAspectRatioConfig object containing equilibrium parameters.\n\nReturns:\n\nr: Physical radius corresponding to rmin * lar_a.\ny: Initial state vector of length 5.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.read_chease2-Tuple{JPEC.Equilibrium.EquilibriumConfig}","page":"Equilibrium","title":"JPEC.Equilibrium.read_chease2","text":"_read_chease2(equil_in)\n\nParses a chease2 file, creates initial 1D and 2D splines, finds magnetic axis, and bundles them into a InverseRunInput object.\n\nArguments:\n\nequil_in: The EquilInput object containing the filename and parameters.\n\nReturns:\n\nA InverseRunInput object ready for the inverse solver.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.read_efit-Tuple{JPEC.Equilibrium.EquilibriumConfig}","page":"Equilibrium","title":"JPEC.Equilibrium.read_efit","text":"_read_efit(equil_in)\n\nParses an EFIT g-file, creates initial 1D and 2D splines, and bundles them into a DirectRunInput object.\n\nArguments:\n\nequil_in: The EquilInput object containing the filename and parameters.\n\nReturns:\n\nA DirectRunInput object ready for the direct solver.\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#JPEC.Equilibrium.setup_equilibrium","page":"Equilibrium","title":"JPEC.Equilibrium.setup_equilibrium","text":"setup_equilibrium(equil_input::EquilInput)\n\nThe main public API for the Equilibrium module. It orchestrates the entire process of reading an equilibrium file, running the appropriate solver, and returning the final processed PlasmaEquilibrium object.\n\nArguments:\n\nequil_input: An EquilInput object containing all necessary setup parameters.\n\nReturns:\n\nA PlasmaEquilibrium object containing the final result.\n\n\n\n\n\n","category":"function"},{"location":"equilibrium/#JPEC.Equilibrium.sol_run-Tuple{JPEC.Equilibrium.EquilibriumConfig, JPEC.Equilibrium.SolevevConfig}","page":"Equilibrium","title":"JPEC.Equilibrium.sol_run","text":"This is a Julia version of the Fortran code in sol.f, implementing Soloviev's analytical equilibrium.\n\nArguments:\n\nmr: Number of radial grid zones\nmz: Number of axial grid zones\nma: Number of flux grid zones\ne: Elongation\na: Minor radius\nr0: Major radius\nq0: Safety factor at the o-point\np0fac: Scales on axis pressure (s*P. beta changes. Phi,q constant)\nb0fac: Scales on toroidal field (sPhi,sf,s^2*P. bt changes. Shape,beta constant)\nf0fac: Scales on toroidal field (s*f. bt,q changes. Phi,p,bp constant)\n\nReturns:\n\nplasma_eq: PlasmaEquilibrium object\n\n\n\n\n\n","category":"method"},{"location":"equilibrium/#Important-types","page":"Equilibrium","title":"Important types","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"EquilibriumConfig — top-level configuration container parsed from a","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"TOML file (outer constructor `EquilibriumConfig(path::String)` is\nprovided).","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"EquilibriumControl — low-level control parameters (grid, jacobian","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"type, tolerances, etc.).","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"EquilibriumOutput — options controlling what output is written.\nPlasmaEquilibrium — the runtime structure containing spline fields,","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"geometry, profiles, and computed diagnostics (q-profile, separatrix,\netc.).","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"LargeAspectRatioConfig, SolevevConfig — convenience structs to","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"construct analytic/model equilibria when using `eq_type = \"lar\"` or\n`eq_type = \"sol\"`.","category":"page"},{"location":"equilibrium/#Key-functions","page":"Equilibrium","title":"Key functions","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"setup_equilibrium(path::String = \"equil.toml\")","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"— main entry point that reads configuration, builds the equilibrium,\nruns the solver, and returns a `PlasmaEquilibrium` instance.","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"equilibrium_separatrix_find!(pe::PlasmaEquilibrium) — locate","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"separatrix and related boundary geometry in-place.","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"equilibrium_global_parameters!(pe::PlasmaEquilibrium) — populate","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"common global parameters (major radius, magnetic axis, volumes, etc.).","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"equilibrium_qfind!(pe::PlasmaEquilibrium) — compute safety factor","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"(q) information across the grid.","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"equilibrium_gse!(pe::PlasmaEquilibrium) — diagnostics on the","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Grad–Shafranov solution.","category":"page"},{"location":"equilibrium/#Example-usage","page":"Equilibrium","title":"Example usage","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Basic example: read a TOML config and build an equilibrium","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"using JPEC\n\n# Build from a TOML file (searches relative paths if needed)\npe = JPEC.Equilibrium.setup_equilibrium(\"docs/examples/dcon.toml\")\n\nprintln(\"Magnetic axis: \", pe.params.r0, \", \", pe.params.z0)\nprintln(\"q(0) = \", pe.params.q0)\n\n# Find separatrix (in-place) and inspect results\nJPEC.Equilibrium.equilibrium_separatrix_find!(pe)\nprintln(\"rsep = \", pe.params.rsep)","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Analytic / testing example: construct a large-aspect-ratio model","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"using JPEC\n\n# Create a LAR config from a small TOML fragment or file\nlarcfg = JPEC.Equilibrium.LargeAspectRatioConfig(lar_r0=10.0, lar_a=1.0, beta0=1e-3)\npe = JPEC.Equilibrium.setup_equilibrium(JPEC.Equilibrium.EquilibriumConfig(control=Dict(\"eq_filename\"=>\"unused\",\"eq_type\"=>\"lar\")), larcfg)\n\nprintln(\"Built LAR equilibrium with a = \", lorcfg.lar_a)","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Notes:","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"The EquilibriumConfig(path::String) constructor parses TOML and","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"expects `[EQUIL_CONTROL]` to contain at minimum `eq_filename` and\n`eq_type` fields. Paths that are not absolute are resolved relative\nto the TOML file location.","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"When eq_type == \"inverse_testing\" a small example inverse run is","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"constructed (useful in tests and examples).","category":"page"},{"location":"equilibrium/#Notes-and-Caveats","page":"Equilibrium","title":"Notes and Caveats","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"Many routines rely on spline representations; the Splines module is","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"used heavily and should be initialized where appropriate.","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"The Equilibrium module contains several reader routines for external","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"formats (EFIT/CHEASE) and also interfaces to older Fortran helpers —\nensure required data files are present for those backends.","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"For programmatic usage, prefer constructing EquilibriumConfig from a","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"TOML file to ensure all path resolution and defaults are handled.","category":"page"},{"location":"equilibrium/#See-also","page":"Equilibrium","title":"See also","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"docs/src/splines.md — spline helpers used by equilibrium routines\ndocs/src/vacuum.md — coupling between equilibrium and vacuum solvers","category":"page"},{"location":"equilibrium/","page":"Equilibrium","title":"Equilibrium","text":"```","category":"page"},{"location":"splines/#Splines-Module","page":"Splines","title":"Splines Module","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"The Splines module provides cubic, bicubic, and fourier spline interpolation functionality, used for smooth representation of MHD equilibria.","category":"page"},{"location":"splines/#Overview","page":"Splines","title":"Overview","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"The module includes:","category":"page"},{"location":"splines/","page":"Splines","title":"Splines","text":"Cubic spline interpolation for 1D data\nBicubic spline interpolation for 2D data\nFourier spline interpolation for decomposed data\nDerivative evaluation capabilities\nSupport for both real and complex-valued data","category":"page"},{"location":"splines/#API-Reference","page":"Splines","title":"API Reference","text":"","category":"section"},{"location":"splines/#JPEC.SplinesMod.BicubicSpline-Tuple{Vector{Float64}, Vector{Float64}, Array{Float64, 3}}","page":"Splines","title":"JPEC.SplinesMod.BicubicSpline","text":"BicubicSpline(xs, ys, fs; \tbctypex::Union{String, Int}=\"not-a-knot\", bctypey::Union{String, Int}=\"not-a-knot\")\n\n## Arguments:\n- `xs`: A vector of Float64 values representing the x-coordinates.\n- `ys`: A vector of Float64 values representing the y-coordinates.\n- `fs`: A 3D array of Float64 values representing the function values at the (x,y) coordinates.\n## Keyword Arguments:\n- `bctypex`: An integer specifying the boundary condition type for x (Default is 4, not a knot)\n- `bctypey`: An integer specifying the boundary condition type for y  (Default is 4, not a knot)\n## Returns:\n- A `BicubicSpline` object containing the spline handle, x-coordinates, y-coordinates,\nfunction values, number of x-coordinates, number of y-coordinates, number of quantities,\nand boundary condition types.\n\n\n\n\n\n","category":"method"},{"location":"splines/#JPEC.SplinesMod.CubicSpline-Union{Tuple{T}, Tuple{Vector{Float64}, VecOrMat{T}}} where T<:Union{Float64, ComplexF64}","page":"Splines","title":"JPEC.SplinesMod.CubicSpline","text":"CubicSpline(xs, fs; bctype=\"not-a-knot\")\n\nArguments:\n  - `xs`: A vector of Float64 values representing the x-coordinates.\n  - `fs`: A vector or matrix of Float64/ComplexF64 values representing the function values at the x-coordinates.\nKeyword Arguments:\n  - `bctype`: Boundary condition type for the cubic spline in `x`.\n    - 1: Natural spline (default)\n    - 2: Periodic spline\n    - 3: Extrapolated spline\n    - 4: \"Not-a-knot\" spline\n\nReturns:\n  - A `CubicSpline` object containing the spline handle, x-coordinates, function values,\n    number of x-coordinates, number of quantities, and index of x position in the spline.\n\n\n\n\n\n","category":"method"},{"location":"splines/#JPEC.SplinesMod.FourierSpline-Tuple{Vector{Float64}, Vector{Float64}, Array{Float64, 3}, Int64}","page":"Splines","title":"JPEC.SplinesMod.FourierSpline","text":"FourierSpline(xs::Vector{Float64}, ys::Vector{Float64}, fs::Array{Float64, 3},     mband::Int; bctype::Union{String, Int}=\"not-a-knot\", fitmethod::Int=1, fitflag::Bool=true)\n\nCreates and fits a function of two variables, f(x, y), to a cubic spline\nin the x-direction and a Fourier series in the y-direction. The y-direction\nis assumed to be periodic.\n\n## Arguments:\n- `xs`: Vector of x-coordinates (length `mx`+1).\n- `ys`: Vector of y-coordinates (length `my`+1, periodic direction).\n- `fs`: 3D array of function values with dimensions (`mx`+1, `my`+1, `nqty`).\n- `mband`: Number of Fourier modes (harmonics) to keep, from 0 to `mband`.\n\n## Keyword Arguments:\n- `bctype`: Boundary condition type for the cubic spline in `x`.\n    - 1: Natural spline (default)\n    - 2: Periodic spline\n    - 3: Extrapolated spline\n    - 4: \"Not-a-knot\" spline\n- `fit_method`: Algorithm for computing Fourier coefficients.\n    - 1: Integration method (for non-uniform `y` grids).\n    - 2: Fast Fourier Transform (FFT) method (requires `length(ys)-1` to be a power of 2).\n\n## Returns:\n- A `FourierSpline` object ready for evaluation.\n\n\n\n\n\n","category":"method"},{"location":"splines/#JPEC.SplinesMod.ReadOnlyArray","page":"Splines","title":"JPEC.SplinesMod.ReadOnlyArray","text":"ReadOnlyArray{T,N,A}\n\nA thin wrapper that provides a read-only view.\n\n\n\n\n\n","category":"type"},{"location":"splines/#JPEC.SplinesMod.bicube_eval","page":"Splines","title":"JPEC.SplinesMod.bicube_eval","text":"bicube_eval(bicube::BicubicSpline, x, y, derivs::Int=0) \t## Arguments: \t- bicube: A BicubicSpline object. \t- x: A Float64 value or a vector of Float64 values representing the x-coordinates to evaluate the bicubic spline at. \t- y: A Float64 value or a vector of Float64 values representing the y-coordinates to evaluate the bicubic spline at. \t## Returns: \t- If x and y are single Float64 values, returns a vector of Float64 values representing the function values at that (x,y) coordinate. \t- If x and y are vectors of Float64 values, returns a 3D array of Float64 values where each slice corresponds to the function values at \tthe respective (x,y) coordinates in x and y.\n\n\n\n\n\n","category":"function"},{"location":"splines/#JPEC.SplinesMod.fspline_eval","page":"Splines","title":"JPEC.SplinesMod.fspline_eval","text":"fspline_eval(fspline::FourierSpline, xs::Vector{Float64}, ys::Vector{Float64}, derivs::Int=0)\n\nEvaluates a fitted Fourier-Spline at given coordinates.\n\n## Arguments:\n- `fspline`: A `FourierSpline` object.\n- `x`: A `Vector{Float64}` of x-coordinates.\n- `y`: A `Vector{Float64}` of y-coordinates.\n\n## Returns:\n- If `x`, `y` are vectors: A tuple of 3D arrays for the function values and derivatives on the grid defined by `x` and `y`.\n\n\n\n\n\n","category":"function"},{"location":"splines/#JPEC.SplinesMod.fspline_eval-2","page":"Splines","title":"JPEC.SplinesMod.fspline_eval","text":"fspline_eval(fspline::FourierSpline, x::Float64, y::Float64, derivs::Int=0)\n\nEvaluates a fitted Fourier-Spline at given coordinates.\n\n## Arguments:\n- `fspline`: A `FourierSpline` object.\n- `x`: A `Float64` x-coordinate.\n- `y`: A `Float64` y-coordinate.\n\n## Returns:\n- If `x`, `y` are scalars: A tuple containing the function value(s) and any requested derivatives. If nqty=1, the results are scalars, otherwise they are vectors.\n\n\n\n\n\n","category":"function"},{"location":"splines/#JPEC.SplinesMod.parse_bctype-Tuple{String}","page":"Splines","title":"JPEC.SplinesMod.parse_bctype","text":"parse_bctype(bctype)\n\nInternal helper to parse a boundary condition into a validated integer code.\n\nArguments:\n\nbctype: The boundary condition as a String or Int. Valid options are:\n\"natural\" or 1\n\"periodic\" or 2\n\"extrap\" or 3\n\"not-a-knot\" or 4\n\nReturns:\n\nA validated Int code (1-4).\n\n\n\n\n\n","category":"method"},{"location":"splines/#JPEC.SplinesMod.spline_eval!-Union{Tuple{T}, Tuple{Vector{T}, JPEC.SplinesMod.CubicSpline{T}, Float64}} where T<:Union{Float64, ComplexF64}","page":"Splines","title":"JPEC.SplinesMod.spline_eval!","text":"spline_eval!(f, spline, x; derivs=0, f1=nothing, f2=nothing, f3=nothing)\n\nIn-place evaluation of CubicSpline at a single point x.\n\nArguments:\n\nf: preallocated vector for the function values (length = spline.nqty).\nspline: the cubic spline object.\nx: Float64 input point.\nderivs: number of derivatives to evaluate (0–3).\nf1, f2, f3: optional preallocated vectors for first, second, third derivatives.\n\nResults are written into f (and optionally f1, f2, f3).\n\n\n\n\n\n","category":"method"},{"location":"splines/#JPEC.SplinesMod.spline_eval-Union{Tuple{T}, Tuple{JPEC.SplinesMod.CubicSpline{T}, Float64}, Tuple{JPEC.SplinesMod.CubicSpline{T}, Float64, Int64}} where T<:Union{Float64, ComplexF64}","page":"Splines","title":"JPEC.SplinesMod.spline_eval","text":"spline_eval(spline::CubicSpline{T}, x, derivs::Int=0) where {T<:Union{Float64, ComplexF64}} \t## Arguments: \t- spline: A Spline object created by CubicSpline. \t- x: A Float64 value or a vector of Float64 values representing the x-coordinates to evaluate the spline at. \t## Returns: \t- If x is a single Float64 value, returns a vector of Float64 values representing the function values at that x-coordinate. \t- If x is a vector of Float64 values, returns a matrix of Float64 values where each row corresponds to the function values at \t  the respective x-coordinate in x. \t- Depending on the derivatives requested, it may return additional vectors for the first, second, or third derivatives.\n\n\n\n\n\n","category":"method"},{"location":"splines/#JPEC.SplinesMod.spline_integrate!-Union{Tuple{JPEC.SplinesMod.CubicSpline{T}}, Tuple{T}} where T<:Union{Float64, ComplexF64}","page":"Splines","title":"JPEC.SplinesMod.spline_integrate!","text":"spline_integrate!(spline::CubicSpline{T}) where {T<:Union{Float64, ComplexF64}}\n\n## Arguments:\n- `spline`: A mutable `Spline` object\".\n\n## Returns:\n- Nothing. Updates `spline._fsi` in place so that\n`spline._fsi[i, :]` equals `∫_{xs[1]}^{xs[i]} f(x) dx` for each component.\n\n\n\n\n\n","category":"method"},{"location":"splines/#Types","page":"Splines","title":"Types","text":"","category":"section"},{"location":"splines/#CubicSplineType","page":"Splines","title":"CubicSplineType","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"Represents a cubic spline interpolation object.","category":"page"},{"location":"splines/#BicubicSplineType","page":"Splines","title":"BicubicSplineType","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"Represents a bicubic spline interpolation object for 2D data.","category":"page"},{"location":"splines/#FourierSplineType","page":"Splines","title":"FourierSplineType","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"Represents a Fourier spline interpolation object for decomposed data.","category":"page"},{"location":"splines/#Functions","page":"Splines","title":"Functions","text":"","category":"section"},{"location":"splines/#CubicSpline","page":"Splines","title":"CubicSpline","text":"","category":"section"},{"location":"splines/#JPEC.SplinesMod.CubicSpline","page":"Splines","title":"JPEC.SplinesMod.CubicSpline","text":"CubicSpline(xs, fs; bctype=\"not-a-knot\")\n\nArguments:\n  - `xs`: A vector of Float64 values representing the x-coordinates.\n  - `fs`: A vector or matrix of Float64/ComplexF64 values representing the function values at the x-coordinates.\nKeyword Arguments:\n  - `bctype`: Boundary condition type for the cubic spline in `x`.\n    - 1: Natural spline (default)\n    - 2: Periodic spline\n    - 3: Extrapolated spline\n    - 4: \"Not-a-knot\" spline\n\nReturns:\n  - A `CubicSpline` object containing the spline handle, x-coordinates, function values,\n    number of x-coordinates, number of quantities, and index of x position in the spline.\n\n\n\n\n\n","category":"type"},{"location":"splines/#spline_eval","page":"Splines","title":"spline_eval","text":"","category":"section"},{"location":"splines/#JPEC.SplinesMod.spline_eval","page":"Splines","title":"JPEC.SplinesMod.spline_eval","text":"spline_eval(spline::CubicSpline{T}, x, derivs::Int=0) where {T<:Union{Float64, ComplexF64}} \t## Arguments: \t- spline: A Spline object created by CubicSpline. \t- x: A Float64 value or a vector of Float64 values representing the x-coordinates to evaluate the spline at. \t## Returns: \t- If x is a single Float64 value, returns a vector of Float64 values representing the function values at that x-coordinate. \t- If x is a vector of Float64 values, returns a matrix of Float64 values where each row corresponds to the function values at \t  the respective x-coordinate in x. \t- Depending on the derivatives requested, it may return additional vectors for the first, second, or third derivatives.\n\n\n\n\n\n","category":"function"},{"location":"splines/#BicubicSpline","page":"Splines","title":"BicubicSpline","text":"","category":"section"},{"location":"splines/#JPEC.SplinesMod.BicubicSpline","page":"Splines","title":"JPEC.SplinesMod.BicubicSpline","text":"BicubicSpline(xs, ys, fs; \tbctypex::Union{String, Int}=\"not-a-knot\", bctypey::Union{String, Int}=\"not-a-knot\")\n\n## Arguments:\n- `xs`: A vector of Float64 values representing the x-coordinates.\n- `ys`: A vector of Float64 values representing the y-coordinates.\n- `fs`: A 3D array of Float64 values representing the function values at the (x,y) coordinates.\n## Keyword Arguments:\n- `bctypex`: An integer specifying the boundary condition type for x (Default is 4, not a knot)\n- `bctypey`: An integer specifying the boundary condition type for y  (Default is 4, not a knot)\n## Returns:\n- A `BicubicSpline` object containing the spline handle, x-coordinates, y-coordinates,\nfunction values, number of x-coordinates, number of y-coordinates, number of quantities,\nand boundary condition types.\n\n\n\n\n\n","category":"type"},{"location":"splines/#bicube_eval","page":"Splines","title":"bicube_eval","text":"","category":"section"},{"location":"splines/#JPEC.SplinesMod.bicube_eval-2","page":"Splines","title":"JPEC.SplinesMod.bicube_eval","text":"bicube_eval(bicube::BicubicSpline, x, y, derivs::Int=0) \t## Arguments: \t- bicube: A BicubicSpline object. \t- x: A Float64 value or a vector of Float64 values representing the x-coordinates to evaluate the bicubic spline at. \t- y: A Float64 value or a vector of Float64 values representing the y-coordinates to evaluate the bicubic spline at. \t## Returns: \t- If x and y are single Float64 values, returns a vector of Float64 values representing the function values at that (x,y) coordinate. \t- If x and y are vectors of Float64 values, returns a 3D array of Float64 values where each slice corresponds to the function values at \tthe respective (x,y) coordinates in x and y.\n\n\n\n\n\n","category":"function"},{"location":"splines/#FourierSpline","page":"Splines","title":"FourierSpline","text":"","category":"section"},{"location":"splines/#JPEC.SplinesMod.FourierSpline","page":"Splines","title":"JPEC.SplinesMod.FourierSpline","text":"FourierSpline(xs::Vector{Float64}, ys::Vector{Float64}, fs::Array{Float64, 3},     mband::Int; bctype::Union{String, Int}=\"not-a-knot\", fitmethod::Int=1, fitflag::Bool=true)\n\nCreates and fits a function of two variables, f(x, y), to a cubic spline\nin the x-direction and a Fourier series in the y-direction. The y-direction\nis assumed to be periodic.\n\n## Arguments:\n- `xs`: Vector of x-coordinates (length `mx`+1).\n- `ys`: Vector of y-coordinates (length `my`+1, periodic direction).\n- `fs`: 3D array of function values with dimensions (`mx`+1, `my`+1, `nqty`).\n- `mband`: Number of Fourier modes (harmonics) to keep, from 0 to `mband`.\n\n## Keyword Arguments:\n- `bctype`: Boundary condition type for the cubic spline in `x`.\n    - 1: Natural spline (default)\n    - 2: Periodic spline\n    - 3: Extrapolated spline\n    - 4: \"Not-a-knot\" spline\n- `fit_method`: Algorithm for computing Fourier coefficients.\n    - 1: Integration method (for non-uniform `y` grids).\n    - 2: Fast Fourier Transform (FFT) method (requires `length(ys)-1` to be a power of 2).\n\n## Returns:\n- A `FourierSpline` object ready for evaluation.\n\n\n\n\n\n","category":"type"},{"location":"splines/#fspline_eval","page":"Splines","title":"fspline_eval","text":"","category":"section"},{"location":"splines/#JPEC.SplinesMod.fspline_eval-3","page":"Splines","title":"JPEC.SplinesMod.fspline_eval","text":"fspline_eval(fspline::FourierSpline, x::Float64, y::Float64, derivs::Int=0)\n\nEvaluates a fitted Fourier-Spline at given coordinates.\n\n## Arguments:\n- `fspline`: A `FourierSpline` object.\n- `x`: A `Float64` x-coordinate.\n- `y`: A `Float64` y-coordinate.\n\n## Returns:\n- If `x`, `y` are scalars: A tuple containing the function value(s) and any requested derivatives. If nqty=1, the results are scalars, otherwise they are vectors.\n\n\n\n\n\nfspline_eval(fspline::FourierSpline, xs::Vector{Float64}, ys::Vector{Float64}, derivs::Int=0)\n\nEvaluates a fitted Fourier-Spline at given coordinates.\n\n## Arguments:\n- `fspline`: A `FourierSpline` object.\n- `x`: A `Vector{Float64}` of x-coordinates.\n- `y`: A `Vector{Float64}` of y-coordinates.\n\n## Returns:\n- If `x`, `y` are vectors: A tuple of 3D arrays for the function values and derivatives on the grid defined by `x` and `y`.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Example-Usage","page":"Splines","title":"Example Usage","text":"","category":"section"},{"location":"splines/#1D-Cubic-Spline","page":"Splines","title":"1D Cubic Spline","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"using JPEC\n\n# Create data points\nxs = collect(range(0.0, stop=2π, length=21))\nfs = sin.(xs)\n\n# Set up spline (1 quantity)\nspline = JPEC.SplinesMod.CubicSpline(xs, hcat(fs), 1)\n\n# Evaluate at new points\nxs_fine = collect(range(0.0, stop=2π, length=100))\nfs_fine = JPEC.SplinesMod.spline_eval(spline, xs_fine)","category":"page"},{"location":"splines/#2D-Bicubic-Spline","page":"Splines","title":"2D Bicubic Spline","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"# Create 2D grid\nxs = collect(range(0.0, stop=2π, length=20))\nys = collect(range(0.0, stop=2π, length=20))\n\n# Create 2D function data\nfs = zeros(20, 20, 1)\nfor i in 1:20, j in 1:20\n    fs[i, j, 1] = sin(xs[i]) * cos(ys[j])\nend\n\n# Set up bicubic spline\nbcspline = JPEC.SplinesMod.BicubicSpline(xs, ys, fs, 1, 1)\n\n# Evaluate with derivatives\nx_eval, y_eval = π/2, π/4\nf, fx, fy = JPEC.SplinesMod.bicube_eval(bcspline, x_eval, y_eval, 1)","category":"page"},{"location":"vacuum/#Vacuum-Module","page":"Vacuum","title":"Vacuum Module","text":"","category":"section"},{"location":"vacuum/","page":"Vacuum","title":"Vacuum","text":"The Vacuum module provides magnetostatic vacuum field calculations with plasma-wall interactions. Refactored/interfaced from/with VACUUM by M.S. Chance.","category":"page"},{"location":"vacuum/#Overview","page":"Vacuum","title":"Overview","text":"","category":"section"},{"location":"vacuum/","page":"Vacuum","title":"Vacuum","text":"The module includes:","category":"page"},{"location":"vacuum/","page":"Vacuum","title":"Vacuum","text":"Interface to Fortran vacuum field calculations\nJulia refactored version of the VACUUM code","category":"page"},{"location":"vacuum/#API-Reference","page":"Vacuum","title":"API Reference","text":"","category":"section"},{"location":"vacuum/#JPEC.VacuumMod.mscvac","page":"Vacuum","title":"JPEC.VacuumMod.mscvac","text":"mscvac(wv, mpert, mtheta, mthvac, complex_flag, kernelsignin, wall_flag, farwal_flag, grrio, xzptso, op_ahgfile=nothing)\n\nCompute the vacuum response matrix for magnetostatic perturbations.\n\nArguments\n\nwv: Pre-allocated complex matrix (mpert × mpert) to store vacuum response (Array{ComplexF64,2})\nmpert: Number of perturbation modes (Integer)\nmtheta: Number of theta grid points for plasma (Integer)\nmthvac: Number of theta grid points for vacuum region (Integer)\ncomplex_flag: Whether to use complex arithmetic (Bool)\nkernelsignin: Sign convention for vacuum kernels (Float64, typically -1.0)\nwall_flag: Whether to include an externally defined wall shape (Bool)\nfarwal_flag: Whether to use far-wall approximation (Bool)\ngrrio: Green's function data (Array{Float64,2})\nxzptso: Source point coordinates (Array{Float64,2})\nop_ahgfile: Optional communication file for when setdconparams is not called (String or Nothing)\n\nReturns\n\nModifies wv in-place with the computed vacuum response matrix\nReturns the modified wv matrix\n\nNote\n\nRequires prior initialization with set_dcon_params() before calling this function.\n\nExamples\n\n# Initialize parameters first\nset_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n\n# Set up vacuum calculation\nmpert = 5\nmtheta = 256\nmthvac = 256\nwv = zeros(ComplexF64, mpert, mpert)\ncomplex_flag = true\nkernelsignin = -1.0\nwall_flag = false\nfarwal_flag = true\ngrrio = rand(Float64, 2 * (mthvac + 5), mpert * 2)\nxzptso = rand(Float64, mthvac + 5, 4)\n\n# Perform calculation\nmscvac(wv, mpert, mtheta, mthvac, complex_flag, kernelsignin,\n    wall_flag, farwal_flag, grrio, xzptso)\n\n\n\n\n\n","category":"function"},{"location":"vacuum/#JPEC.VacuumMod.set_dcon_params-Tuple{Integer, Integer, Integer, Integer, Float64, Vector{Float64}, Vector{Float64}, Vector{Float64}}","page":"Vacuum","title":"JPEC.VacuumMod.set_dcon_params","text":"set_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n\nInitialize DCON (Displacement CONtinuum) parameters for vacuum field calculations.\n\nArguments\n\nmthin: Number of theta grid points (Integer)\nlmin: Minimum poloidal mode number (Integer)\nlmax: Maximum poloidal mode number (Integer)\nnnin: Toroidal mode number (Integer)\nqa1in: Safety factor parameter (Float64)\nxin: Vector of radial coordinates at plasma boundary (Vector{Float64})\nzin: Vector of vertical coordinates at plasma boundary (Vector{Float64})\ndeltain: Vector of displacement values (Vector{Float64})\n\nNote\n\nThis function must be called before using mscvac to perform vacuum calculations. The coordinate and displacement vectors should have length lmax - lmin + 1.\n\nExamples\n\nmthin, lmin, lmax, nnin = Int32(4), Int32(1), Int32(4), Int32(2)\nqa1in = 1.23\nn_modes = lmax - lmin + 1\nxin = rand(Float64, n_modes)\nzin = rand(Float64, n_modes)\ndeltain = rand(Float64, n_modes)\n\nset_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n\n\n\n\n\n","category":"method"},{"location":"vacuum/#Functions","page":"Vacuum","title":"Functions","text":"","category":"section"},{"location":"vacuum/#set*dcon*params","page":"Vacuum","title":"setdconparams","text":"","category":"section"},{"location":"vacuum/#JPEC.VacuumMod.set_dcon_params","page":"Vacuum","title":"JPEC.VacuumMod.set_dcon_params","text":"set_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n\nInitialize DCON (Displacement CONtinuum) parameters for vacuum field calculations.\n\nArguments\n\nmthin: Number of theta grid points (Integer)\nlmin: Minimum poloidal mode number (Integer)\nlmax: Maximum poloidal mode number (Integer)\nnnin: Toroidal mode number (Integer)\nqa1in: Safety factor parameter (Float64)\nxin: Vector of radial coordinates at plasma boundary (Vector{Float64})\nzin: Vector of vertical coordinates at plasma boundary (Vector{Float64})\ndeltain: Vector of displacement values (Vector{Float64})\n\nNote\n\nThis function must be called before using mscvac to perform vacuum calculations. The coordinate and displacement vectors should have length lmax - lmin + 1.\n\nExamples\n\nmthin, lmin, lmax, nnin = Int32(4), Int32(1), Int32(4), Int32(2)\nqa1in = 1.23\nn_modes = lmax - lmin + 1\nxin = rand(Float64, n_modes)\nzin = rand(Float64, n_modes)\ndeltain = rand(Float64, n_modes)\n\nset_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n\n\n\n\n\n","category":"function"},{"location":"vacuum/#mscvac","page":"Vacuum","title":"mscvac","text":"","category":"section"},{"location":"vacuum/#JPEC.VacuumMod.mscvac-2","page":"Vacuum","title":"JPEC.VacuumMod.mscvac","text":"mscvac(wv, mpert, mtheta, mthvac, complex_flag, kernelsignin, wall_flag, farwal_flag, grrio, xzptso, op_ahgfile=nothing)\n\nCompute the vacuum response matrix for magnetostatic perturbations.\n\nArguments\n\nwv: Pre-allocated complex matrix (mpert × mpert) to store vacuum response (Array{ComplexF64,2})\nmpert: Number of perturbation modes (Integer)\nmtheta: Number of theta grid points for plasma (Integer)\nmthvac: Number of theta grid points for vacuum region (Integer)\ncomplex_flag: Whether to use complex arithmetic (Bool)\nkernelsignin: Sign convention for vacuum kernels (Float64, typically -1.0)\nwall_flag: Whether to include an externally defined wall shape (Bool)\nfarwal_flag: Whether to use far-wall approximation (Bool)\ngrrio: Green's function data (Array{Float64,2})\nxzptso: Source point coordinates (Array{Float64,2})\nop_ahgfile: Optional communication file for when setdconparams is not called (String or Nothing)\n\nReturns\n\nModifies wv in-place with the computed vacuum response matrix\nReturns the modified wv matrix\n\nNote\n\nRequires prior initialization with set_dcon_params() before calling this function.\n\nExamples\n\n# Initialize parameters first\nset_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n\n# Set up vacuum calculation\nmpert = 5\nmtheta = 256\nmthvac = 256\nwv = zeros(ComplexF64, mpert, mpert)\ncomplex_flag = true\nkernelsignin = -1.0\nwall_flag = false\nfarwal_flag = true\ngrrio = rand(Float64, 2 * (mthvac + 5), mpert * 2)\nxzptso = rand(Float64, mthvac + 5, 4)\n\n# Perform calculation\nmscvac(wv, mpert, mtheta, mthvac, complex_flag, kernelsignin,\n    wall_flag, farwal_flag, grrio, xzptso)\n\n\n\n\n\n","category":"function"},{"location":"vacuum/#Example-Usage","page":"Vacuum","title":"Example Usage","text":"","category":"section"},{"location":"vacuum/#Basic-Vacuum-Calculation","page":"Vacuum","title":"Basic Vacuum Calculation","text":"","category":"section"},{"location":"vacuum/","page":"Vacuum","title":"Vacuum","text":"using JPEC\n\n# Set DCON parameters\nmthin, lmin, lmax, nnin = Int32(4), Int32(1), Int32(4), Int32(2)\nqa1in = 1.23\nxin = rand(Float64, lmax - lmin + 1)\nzin = rand(Float64, lmax - lmin + 1) \ndeltain = rand(Float64, lmax - lmin + 1)\n\n# Initialize DCON interface\nJPEC.VacuumMod.set_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n\n# Set up vacuum calculation parameters\nmpert = 5\nmtheta = 256\nmthvac = 256\nwv = zeros(ComplexF64, mpert, mpert)\ncomplex_flag = true\nkernelsignin = -1.0\nwall_flag = false\nfarwal_flag = true\ngrrio = rand(Float64, 2*(mthvac+5), mpert*2)\nxzptso = rand(Float64, mthvac+5, 4)\n\n# Perform vacuum calculation\nJPEC.VacuumMod.mscvac(\n    wv, mpert, mtheta, mthvac,\n    complex_flag, kernelsignin,\n    wall_flag, farwal_flag,\n    grrio, xzptso\n)","category":"page"},{"location":"vacuum/#Notes","page":"Vacuum","title":"Notes","text":"","category":"section"},{"location":"vacuum/","page":"Vacuum","title":"Vacuum","text":"Requires proper initialization of DCON parameters before use\nSupports both complex and real arithmetic depending on the application","category":"page"},{"location":"examples/splines/#Spline-Examples","page":"Spline Examples","title":"Spline Examples","text":"","category":"section"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"This page demonstrates the usage of the Splines module with practical examples.","category":"page"},{"location":"examples/splines/#1D-Cubic-Spline-Interpolation","page":"Spline Examples","title":"1D Cubic Spline Interpolation","text":"","category":"section"},{"location":"examples/splines/#Basic-Usage","page":"Spline Examples","title":"Basic Usage","text":"","category":"section"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"using JPEC, Plots\n\n# Create sample data\nxs = collect(range(0.0, stop=2π, length=21))\nfs = sin.(xs)\nfc = cos.(xs)\n\n# Combine into matrix (each column is a different quantity)\nfs_matrix = hcat(fs, fc)\n\n# Set up spline for 2 quantities\nspline = JPEC.SplinesMod.CubicSpline(xs, fs_matrix, 2)\n\n# Evaluate on fine grid\nxs_fine = collect(range(0.0, stop=2π, length=100))\nfs_fine = JPEC.SplinesMod.spline_eval(spline, xs_fine)\n\n# Plot results\nplot(xs_fine, fs_fine[:, 1], label=\"sin(x) spline\", legend=:topright)\nplot!(xs_fine, fs_fine[:, 2], label=\"cos(x) spline\")\nscatter!(xs, fs, label=\"sin(x) data\")\nscatter!(xs, fc, label=\"cos(x) data\")","category":"page"},{"location":"examples/splines/#Complex-valued-Splines","page":"Spline Examples","title":"Complex-valued Splines","text":"","category":"section"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"# Create complex exponential data\nxs = collect(range(0.0, stop=2π, length=20))\nfm = exp.(-im .* xs)  # e^(-ix)\nfp = exp.(im .* xs)   # e^(ix)\n\n# Combine complex data\nfs_matrix = hcat(fm, fp)\n\n# Set up complex spline\nspline = JPEC.SplinesMod.CubicSpline(xs, fs_matrix, 2)\n\n# Evaluate\nxs_fine = collect(range(0.0, stop=2π, length=100))\nfs_fine = JPEC.SplinesMod.spline_eval(spline, xs_fine)\n\n# Plot real and imaginary parts\nplot(xs_fine, real.(fs_fine[:, 1]), label=\"Re(e^(-ix))\")\nplot!(xs_fine, imag.(fs_fine[:, 1]), label=\"Im(e^(-ix))\")","category":"page"},{"location":"examples/splines/#2D-Bicubic-Spline-Interpolation","page":"Spline Examples","title":"2D Bicubic Spline Interpolation","text":"","category":"section"},{"location":"examples/splines/#Basic-2D-Function","page":"Spline Examples","title":"Basic 2D Function","text":"","category":"section"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"using JPEC, Plots\n\n# Create 2D grid\nxs = collect(range(0.0, stop=2π, length=20))\nys = collect(range(0.0, stop=2π, length=20))\n\n# Create 2D function data\nfs1 = sin.(xs') .* cos.(ys) .+ 1.0\nfs2 = cos.(xs') .* sin.(ys) .+ 1.0\n\n# Prepare data array (nx × ny × nquantities)\nfs = zeros(20, 20, 2)\nfs[:, :, 1] = fs1\nfs[:, :, 2] = fs2\n\n# Set up bicubic spline\nbcspline = JPEC.SplinesMod.bicube_setup(xs, ys, fs, 2, 2)\n\n# Evaluate on fine grid\nxs_fine = collect(range(0.0, stop=2π, length=100))\nys_fine = collect(range(0.0, stop=2π, length=100))\nfs_fine = JPEC.SplinesMod.bicube_eval(bcspline, xs_fine, ys_fine)\n\n# Create contour plot\ncontourf(xs_fine, ys_fine, fs_fine[:, :, 1]', \n         title=\"Bicubic Spline: sin(x)cos(y) + 1\")","category":"page"},{"location":"examples/splines/#With-Derivatives","page":"Spline Examples","title":"With Derivatives","text":"","category":"section"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"# Evaluate with first derivatives\nfs_fine, fsx_fine, fsy_fine = JPEC.SplinesMod.bicube_eval(bcspline, xs_fine, ys_fine, 1)\n\n# Plot function and derivatives\np1 = contourf(xs_fine, ys_fine, fs_fine[:, :, 1]', title=\"f(x,y)\")\np2 = contourf(xs_fine, ys_fine, fsx_fine[:, :, 1]', title=\"∂f/∂x\")\np3 = contourf(xs_fine, ys_fine, fsy_fine[:, :, 1]', title=\"∂f/∂y\")\n\nplot(p1, p2, p3, layout=(1,3), size=(1200, 400))","category":"page"},{"location":"examples/splines/#Equilibrium-Example","page":"Spline Examples","title":"Equilibrium Example","text":"","category":"section"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"This example shows spline usage with the Solov'ev equilibrium:","category":"page"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"# Create equilibrium parameters\nkappa = 1.8  # elongation\na = 1.0      # minor radius  \nr0 = 3.5     # major radius\nq0 = 1.25    # safety factor\n\n# Create spatial grid\nmr, mz = 40, 43\nrmin, rmax = r0 - 1.5*a, r0 + 1.5*a\nzmin, zmax = -1.5*kappa*a, 1.5*kappa*a\n\nrs = collect(range(rmin, stop=rmax, length=mr))\nzs = collect(range(zmin, stop=zmax, length=mz))\n\n# Create Solov'ev equilibrium psi field\nf0 = r0 * 1.0  # b0fac = 1.0\npsio = kappa * f0 * a^2 / (2 * q0 * r0)\npsifac = psio / (a*r0)^2\nefac = 1/kappa^2\n\npsifs = zeros(mr, mz, 1)\nfor i in 1:mr, j in 1:mz\n    psifs[i, j, 1] = psio - psifac * (efac * (rs[i] * zs[j])^2 + (rs[i]^2-r0^2)^2/4)\nend\n\n# Set up bicubic spline for psi\npsi_spline = JPEC.SplinesMod.bicube_setup(rs, zs, psifs, 3, 3)\n\n# Evaluate on fine grid for plotting\nrs_fine = collect(range(rmin, stop=rmax, length=110))\nzs_fine = collect(range(zmin, stop=zmax, length=100))\npsi_fine = JPEC.SplinesMod.bicube_eval(psi_spline, rs_fine, zs_fine)\n\n# Create contour plot\ncontourf(rs_fine, zs_fine, psi_fine[:, :, 1]', \n         title=\"Ψ: Solov'ev Equilibrium\", \n         xlabel=\"R\", ylabel=\"Z\",\n         aspect_ratio=:equal)","category":"page"},{"location":"examples/splines/#Performance-Tips","page":"Spline Examples","title":"Performance Tips","text":"","category":"section"},{"location":"examples/splines/","page":"Spline Examples","title":"Spline Examples","text":"Batch evaluations: Evaluate multiple points simultaneously for better performance\nMemory management: Splines should not be re-created frequently; reuse existing spline objects","category":"page"},{"location":"examples/equilibrium/#Equilibrium-Development-Examples","page":"Equilibrium Examples","title":"Equilibrium Development Examples","text":"","category":"section"},{"location":"examples/equilibrium/","page":"Equilibrium Examples","title":"Equilibrium Examples","text":"This page demonstrates equilibrium development and analysis using JPEC, based on the Solov'ev analytical equilibrium.","category":"page"},{"location":"examples/equilibrium/#Equilibrium-Setup","page":"Equilibrium Examples","title":"Equilibrium Setup","text":"","category":"section"},{"location":"examples/equilibrium/#Basic-Data-Structures","page":"Equilibrium Examples","title":"Basic Data Structures","text":"","category":"section"},{"location":"examples/vacuum/#Vacuum-Examples","page":"Vacuum Examples","title":"Vacuum Examples","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"This page demonstrates the usage of the Vacuum module for magnetostatic calculations.","category":"page"},{"location":"examples/vacuum/#Basic-Vacuum-Field-Calculation","page":"Vacuum Examples","title":"Basic Vacuum Field Calculation","text":"","category":"section"},{"location":"examples/vacuum/#Setting-up-DCON-Parameters","page":"Vacuum Examples","title":"Setting up DCON Parameters","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"The vacuum module requires initialization with DCON (Displacement CONtinuum) parameters:","category":"page"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"using JPEC\n\n# Define DCON parameters\nmthin = Int32(4)     # Number of theta points\nlmin = Int32(1)      # Minimum poloidal mode number\nlmax = Int32(4)      # Maximum poloidal mode number\nnnin = Int32(2)      # Toroidal mode number\nqa1in = 1.23         # Safety factor parameter\n\n# Create geometry arrays\nn_modes = lmax - lmin + 1\nxin = rand(Float64, n_modes)      # Radial coordinates\nzin = rand(Float64, n_modes)      # Vertical coordinates  \ndeltain = rand(Float64, n_modes)  # Displacement data\n\n# Initialize DCON interface\nJPEC.VacuumMod.set_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)","category":"page"},{"location":"examples/vacuum/#Vacuum-Matrix-Calculation","page":"Vacuum Examples","title":"Vacuum Matrix Calculation","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"# Set up vacuum calculation parameters\nmpert = 5              # Number of perturbation modes\nmtheta = 256           # Number of theta points for plasma\nmthvac = 256           # Number of theta points for vacuum\n\n# Initialize result matrix\nwv = zeros(ComplexF64, mpert, mpert)\n\n# Calculation flags\ncomplex_flag = true     # Use complex arithmetic\nkernelsignin = -1.0    # Kernel sign \nwall_flag = false      # Include wall effects\nfarwal_flag = true     # Far wall approximation\n\n# Geometry and source data\ngrrio = rand(Float64, 2*(mthvac+5), mpert*2)  # Geometry data\nxzptso = rand(Float64, mthvac+5, 4)           # Source points\n\n# Perform vacuum matrix calculation\nJPEC.VacuumMod.mscvac(\n    wv, mpert, mtheta, mthvac,\n    complex_flag, kernelsignin,\n    wall_flag, farwal_flag,\n    grrio, xzptso\n)\n\nprintln(\"Vacuum matrix calculation completed\")\nprintln(\"Result matrix dimensions: \", size(wv))","category":"page"},{"location":"examples/vacuum/#Analyzing-Results","page":"Vacuum Examples","title":"Analyzing Results","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"using Plots\n\n# Plot magnitude of vacuum matrix elements\nheatmap(abs.(wv), \n        title=\"Vacuum Matrix |W| Elements\",\n        xlabel=\"Mode j\", \n        ylabel=\"Mode i\",\n        color=:plasma)\n\n# Plot phase information\nheatmap(angle.(wv), \n        title=\"Vacuum Matrix Phase\",\n        xlabel=\"Mode j\",\n        ylabel=\"Mode i\", \n        color=:phase)","category":"page"},{"location":"examples/vacuum/#Advanced-Usage","page":"Vacuum Examples","title":"Advanced Usage","text":"","category":"section"},{"location":"examples/vacuum/#Including-Wall-Effects","page":"Vacuum Examples","title":"Including Wall Effects","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"# Enable wall calculations\nwall_flag = true\nfarwal_flag = false  # Do not use far wall approximation\n\n# Additional wall parameters might be needed\n# (specific implementation depends on geometry)\n\nJPEC.VacuumMod.mscvac(\n    wv, mpert, mtheta, mthvac,\n    complex_flag, kernelsignin,\n    wall_flag, farwal_flag,\n    grrio, xzptso\n)","category":"page"},{"location":"examples/vacuum/#Multi-mode-Analysis","page":"Vacuum Examples","title":"Multi-mode Analysis","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"# Analyze eigenvalues of vacuum matrix\nusing LinearAlgebra\n\neigenvals = eigvals(wv)\neigenvecs = eigvecs(wv)\n\n# Plot eigenvalue spectrum\nscatter(real.(eigenvals), imag.(eigenvals),\n        title=\"Vacuum Matrix Eigenvalues\",\n        xlabel=\"Real part\",\n        ylabel=\"Imaginary part\",\n        legend=false)\n\n# Identify most unstable mode\nmax_growth_idx = argmax(imag.(eigenvals))\nprintln(\"Most unstable eigenvalue: \", eigenvals[max_growth_idx])","category":"page"},{"location":"examples/vacuum/#Coupling-with-Equilibrium-Data","page":"Vacuum Examples","title":"Coupling with Equilibrium Data","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"# This example shows how vacuum calculations integrate with equilibrium\n\n# 1. Set up equilibrium (using spline example from equilibrium page)\n# ... equilibrium setup code ...\n\n# 2. Extract boundary data for vacuum calculation\n# boundary_data = extract_boundary(psi_spline, flux_surface)\n\n# 3. Convert to DCON format\n# xin, zin, deltain = process_boundary_data(boundary_data)\n\n# 4. Perform vacuum calculation\n# JPEC.VacuumMod.set_dcon_params(mthin, lmin, lmax, nnin, qa1in, xin, zin, deltain)\n# ... vacuum calculation ...\n\n# 5. Analyze stability\n# stability_analysis(wv, eigenvals)","category":"page"},{"location":"examples/vacuum/#Troubleshooting","page":"Vacuum Examples","title":"Troubleshooting","text":"","category":"section"},{"location":"examples/vacuum/#Common-Issues","page":"Vacuum Examples","title":"Common Issues","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"Initialization Error: Ensure set_dcon_params is called before mscvac\nMemory Issues: Large mtheta/mthvac values require significant memory\nConvergence: Check that geometry arrays are properly normalized\nComplex Arithmetic: Ensure complex_flag=true for stability analysis","category":"page"},{"location":"examples/vacuum/#Performance-Optimization","page":"Vacuum Examples","title":"Performance Optimization","text":"","category":"section"},{"location":"examples/vacuum/","page":"Vacuum Examples","title":"Vacuum Examples","text":"# For large problems, consider:\n# - Reducing mtheta/mthvac if possible\n# - Using real arithmetic (complex_flag=false) when appropriate  \n# - Parallelization (if available in Fortran backend)\n\n# Monitor memory usage\nusing Pkg\nPkg.add(\"BenchmarkTools\")\nusing BenchmarkTools\n\n@time JPEC.VacuumMod.mscvac(wv, mpert, mtheta, mthvac, \n                           complex_flag, kernelsignin,\n                           wall_flag, farwal_flag,\n                           grrio, xzptso)","category":"page"},{"location":"#JPEC.jl","page":"Home","title":"JPEC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia implementation of the Generalized Perturbed Equilibrium Code suite","category":"page"},{"location":"","page":"Home","title":"Home","text":"JPEC.jl is a work-in-progress Julia port of the Generalized Perturbed Equilibrium Code (GPEC) suite, providing tools for magnetohydrodynamic (MHD) equilibrium and stability analysis in fusion plasmas.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JPEC provides functionality for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"some stuff Fill this in later","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"JPEC\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JPEC\n\n# Great question","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"splines.md\", \"vacuum.md\", \"equilibrium.md\"]\nDepth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package includes several Jupyter notebook examples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"example.ipynb: Fill this in later","category":"page"},{"location":"#Developer-Notes","page":"Home","title":"Developer Notes","text":"","category":"section"},{"location":"#Commit-Messages","page":"Home","title":"Commit Messages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To assist with release note compilation, please follow the commit message format:","category":"page"},{"location":"","page":"Home","title":"Home","text":"CODE - TAG - Detailed message","category":"page"},{"location":"","page":"Home","title":"Home","text":"where CODE is EQUIL, DCON, VAC, etc. and TAGs are descriptors like WIP, MINOR, IMPROVEMENT, BUG FIX, NEW FEATURE, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, please see this google doc for more details on using the GitHub.","category":"page"},{"location":"#Links","page":"Home","title":"Links","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Source Repository\nOriginal GPEC","category":"page"}]
}
